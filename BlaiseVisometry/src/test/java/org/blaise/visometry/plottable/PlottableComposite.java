/**
 * PlottableComposite.java
 * Created on Feb 25, 2008
 */
package org.blaise.visometry.plottable;

import java.util.ArrayList;
import java.util.Collection;
import org.blaise.math.coordinate.Domain;
import org.blaise.math.coordinate.DomainContext;
import org.blaise.math.coordinate.DomainHint;
import org.blaise.math.coordinate.SampleSet;
import org.blaise.math.coordinate.ScreenSampleDomainProvider;
import org.blaise.visometry.VGraphic;
import org.blaise.visometry.VGraphicComposite;

/**
 * <p>
 *  Maintains a group of {@link Plottable}s, and a parallel {@link VGraphicComposite}
 *  that stores local graphics primitives generated by those plottables.
 * </p>
 * <p>
 *  A second major functionality is maintaining a {@link DomainContext},
 *  which provides plottables in the group with access to domains keyed by strings.
 *  The key use case is providing information about the underlying window, e.g. the
 *  range of x-coordinates in view. The {@code DomainContext}s are hierarchical,
 *  so that lookups will pass up the tree of {@code PlottableComposite}s until finding
 *  the requested domain.
 * </p>
 *
 * @param <C> class representing the underlying coordinate
 *
 * @author Elisha Peterson
 */
public class PlottableComposite<C> extends PlottableSupport<C> {

    /** Stores the elements in the group. */
    protected final ArrayList<Plottable<C>> plottables = new ArrayList<Plottable<C>>();
    /** The graphic entry container for the plottables */
    protected final VGraphicComposite<C> compositeEntry = new VGraphicComposite<C>();

    @Override
    public String toString() {
        return "Plottable Group [" + plottables.size() + " elements]";
    }

    //
    // PROPERTIES
    //

    public VGraphicComposite getGraphicEntry() {
        return compositeEntry;
    }

    public Plottable[] getPlottable() {
        return plottables.toArray(new Plottable[]{});
    }
    public Plottable getPlottable(int i) {
        return plottables.get(i);
    }

    public void setPlottable(Plottable[] pl) {
        plottables.clear();
        for (int i = 0; i < pl.length; i++) {
            if (plottables.get(i) != null)
                plottables.get(i).setParent(null);
            pl[i].setParent(this);
            add(pl[i]);
        }
        fireComputeNeeded();
    }
    public void setPlottable(int i, Plottable p) {
        if (plottables.get(i) != null)
            plottables.get(i).setParent(null);
        plottables.set(i, p);
        p.setParent(this);
        fireComputeNeeded();
    }

    //
    // COMPOSITIONAL
    //

    /**
     * Remove all plottables from the group. Also de-registers each as a listener.
     */
    public void clear() {
        for (Plottable p : plottables)
            if (p.getParent() == this)
                p.setParent(null);
        plottables.clear();
        fireComputeNeeded();
    }

    /**
     * Adds specified plottable to the group, provided it is not already there.
     * Also sets up change listening.
     * @param plottable the plottable to add.
     */
    public void add(Plottable<C> plottable) {
        if (!plottables.contains(plottable))
            plottables.add(plottable);
        plottable.setParent(this);
        fireComputeNeeded();
    }

    public void add(int index, Plottable<C> plottable) {
        if (plottables.contains(plottable) && plottables.indexOf(plottable) != index)
            plottables.remove(plottable);
        plottables.add(index, plottable);
        plottable.setParent(this);
        fireComputeNeeded();
    }

    /**
     * Adds specified plottables to the group. Also sets up change listening.
     * @param pp the plottables to add.
     */
    public void addAll(Collection<? extends Plottable<C>> pp) {
        for (Plottable p : pp) {
            if (!plottables.contains(p))
                plottables.add(p);
            p.setParent(this);
        }
        fireComputeNeeded();
    }

    /**
     * Removes specified plottable from the group, and removes this class as a listener.
     * @param plottable the plottable to remove.
     * @return value of remove operation
     */
    public boolean remove(Plottable<C> plottable) {
        if (plottables.remove(plottable)) {
            if (plottable.getParent() == this)
                plottable.setParent(null);
            fireComputeNeeded();
            return true;
        }
        return false;
    }

    //
    // COMPUTATIONAL/VISUAL
    //

    @Override
    public boolean isUncomputed() {
        if (uncomputed)
            return true;
        for (Plottable p : plottables)
            if (p.isUncomputed())
                return true;
        return false;
    }

    @Override
    public synchronized void recompute() {
        boolean change = false;
        for (Plottable p : plottables) {
            if (p.isUncomputed()) {
                p.recompute();
                change = true;
            }
        }
        if (change)
            updateEntries();
        uncomputed = false;
    }

    public synchronized void recomputeAll() {
        for (Plottable p : plottables) {
            if (p instanceof PlottableComposite)
                ((PlottableComposite)p).recomputeAll();
            else
                p.recompute();
        }
        updateEntries();
        uncomputed = false;
    }

    protected void updateEntries() {
        ArrayList<VGraphic<C>> old = new ArrayList<VGraphic<C>>();
        ArrayList<VGraphic<C>> remove = new ArrayList<VGraphic<C>>();
        for (VGraphic<C> gfc : compositeEntry.getGraphics()) {
            old.add(gfc);
            remove.add(gfc);
        }

        for (Plottable p : plottables) {
            VGraphic<C> en = p.getGraphicEntry();
            if (old.contains(en))
                remove.remove(en);
            else
                compositeEntry.addGraphic(en);
        }

        for (VGraphic<C> en : remove)
            compositeEntry.removeGraphic(en);
    }

    //
    // PLOTTABLE EVENT HANDLING
    //

    /**
     * Called when a plottable updates its state in some way, e.g. when it
     * has changed and needs to be redrawn. This marks the group as needing
     * computation and redraw, and notifies the parent and any interested
     * <code>ChangeListener</code>'s.
     * @param p the plottable
     */
    public void computeNeeded(Plottable p) {
        fireComputeNeeded();
    }


    //<editor-fold defaultstate="collapsed" desc="DOMAINS/CONTEXTUAL METHODS">
    //
    // DOMAINS/CONTEXTUAL METHODS
    //

    /** Stores any sample generators associated with this group. */
    DomainContext domains;

    /**
     * Registers a domain with the sampling context.
     * @param id identification value for the domain
     * @param domain the domain
     * @param cls the class type of the sampler
     */
    public <T> void registerDomain(String id, Domain<T> domain, Class<? extends T> cls) {
        if (domains == null)
            domains = new DomainContext();
        domains.addEntry(id, domain, cls);
    }

    /**
     * Attempts to find an appropriate sampler for the given class. If unable to
     * find one, returns null.
     *
     * @param cls the type of sample being requested
     * @param id used to describe which object is being requested
     * @return a sampler of specified type
     */
    protected <T> Domain<T> lookupDomain(String id, Class<? extends T> cls) {
        return domains == null ? null : domains.getDomain(id, cls);
    }

    /**
     * This method allows a plottable to request an appropriate sampler from the group.
     * The group is responsible for finding an appropriate sampler and (if supported)
     * adding event support to notify the plottable when the settings within the sampler change.
     *
     * @param id used to describe which object is being requested
     * @param cls the type of sample being requested
     * @return a sampler appropriate for use by the plottable; possibly a null value if an
     *   appropriate sampler cannot be found
     */
    public <T> Domain<T> requestDomain(String id, Class<? extends T> cls) {
        Domain dom = lookupDomain(id, cls);
        if (dom == null && parent != null)
            dom = parent.requestDomain(id, cls);
        return dom;
    }

    /**
     * This method allows a plottable to request a sampler configured for a specified
     * number of pixels per sample.
     *
     * @param id used to describe which object is being requested
     * @param cls the type of sample being requested
     * @param pixels desired number of pixels per sample
     * @param hint a key representing the type of sampling desired
     * @return a sampler appropriate for use by the plottable; possibly a null value if an
     *   appropriate sampler cannot be found
     */
    public <T> SampleSet<T> requestScreenSampleDomain(String id, Class<? extends T> cls, float pixels, DomainHint hint) {
        Domain dom = lookupDomain(id, cls);
        if (dom == null && parent != null)
            dom = parent.requestDomain(id, cls);
        if (dom instanceof ScreenSampleDomainProvider)
            return ((ScreenSampleDomainProvider)dom).samplerWithPixelSpacing(pixels, hint);
        return null;
    }

    //</editor-fold>

}
